// export class BoxCraft {
//     constructor(element) {
//       this.element = element;
//       // Common properties for selection tools could be initialized here
//     }
//     init() {
//       // Initialization logic common to both selectors could be here
//       //   console.log("BoxCraft.init")
//       // this.element.width = window.innerWidth;
//       // this.element.height = window.innerHeight;
//       // this.element.style.border = "2px solid red";
//       // this.element.style.position = 'absolute';
//       // this.element.style.top = '0';
//       // this.element.style.left = '0';
//       this.element.style.zIndex = '1000';  // High value to ensure it's on top
//     }
//     // Common methods for both selectors could be added here
//   }
class $5018ea9c30d774e7$export$247262aa28c26769 {
    constructor(element){
        this.element = element; // The base image element
        // Common properties for selection tools could be initialized here
        // Create a new canvas element
        this.overlayCanvas = document.createElement("canvas");
    }
    init() {
        // Set the dimensions of the canvas to match the base image
        this.overlayCanvas.width = this.element.width;
        this.overlayCanvas.height = this.element.height;
        // Style the canvas to overlay the base image
        this.overlayCanvas.style.position = "absolute";
        this.overlayCanvas.style.left = this.element.offsetLeft + "px";
        this.overlayCanvas.style.top = this.element.offsetTop + "px";
        this.overlayCanvas.style.zIndex = "1000"; // High value to ensure it's on top
        this.ctx = this.overlayCanvas.getContext("2d");
        this.ctx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
        // Append the overlay canvas to the same parent element as the base image
        this.element.parentElement.appendChild(this.overlayCanvas);
    }
}



class $c8d567a4be5c9a89$export$dd23631818154ff extends (0, $5018ea9c30d774e7$export$247262aa28c26769) {
    constructor(element, callback){
        super(element);
        this.callback = callback;
        this.rect = {};
        this.handleRadius = 7;
        this.dragTL = this.dragBL = this.dragTR = this.dragBR = false;
        this.dragWholeRect = false;
    }
    init() {
        super.init();
        // this.canvas = this.element;
        // this.initCanvas();
        this.initRect();
        this.drawRectInCanvas();
        this.attachResizeListeners();
    }
    initCanvas() {
    // // Assuming `image` is globally available or passed to the constructor
    // this.canvas.height = image.height;
    // this.canvas.width = image.width;
    // this.canvas.style.top = image.offsetTop + "px";
    // this.canvas.style.left = image.offsetLeft + "px";
    // Assuming `element` is globally available or passed to the constructor
    // this.canvas.height = this.element.height;
    // this.canvas.width = this.element.width;
    // this.canvas.style.top = this.element.offsetTop + "px";
    // this.canvas.style.left = this.element.offsetLeft + "px";
    }
    initRect() {
        this.rect.height = 200;
        this.rect.width = 200;
        this.rect.left = (window.innerWidth - this.rect.width) / 2;
        this.rect.top = (window.innerHeight - this.rect.height) / 2;
    }
    drawRectInCanvas() {
        var ctx = this.overlayCanvas.getContext("2d");
        ctx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
        ctx.beginPath();
        ctx.lineWidth = "1";
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
        ctx.strokeStyle = "#000000";
        ctx.rect(this.rect.left, this.rect.top, this.rect.width, this.rect.height);
        ctx.fill();
        ctx.stroke();
    // this.drawHandles();
    }
    // drawHandles() {
    //   this.drawCircle(this.rect.left, this.rect.top, this.handleRadius);
    //   this.drawCircle(this.rect.left + this.rect.width, this.rect.top, this.handleRadius);
    //   this.drawCircle(this.rect.left + this.rect.width, this.rect.top + this.rect.height, this.handleRadius);
    //   this.drawCircle(this.rect.left, this.rect.top + this.rect.height, this.handleRadius);
    // }
    // drawCircle(x, y, radius) {
    //   var ctx = this.overlayCanvas.getContext("2d");
    //   ctx.fillStyle = "#000000";
    //   ctx.beginPath();
    //   ctx.arc(x, y, radius, 0, 2 * Math.PI);
    // ctx.fill();
    // }
    attachResizeListeners() {
        this.overlayCanvas.addEventListener("mousedown", this.mouseDown.bind(this), false);
        this.overlayCanvas.addEventListener("mouseup", this.mouseUp.bind(this), false);
        this.overlayCanvas.addEventListener("mousemove", this.mouseMove.bind(this), false);
    }
    mouseDown(e) {
        // ... implementation of mouseDown
        let pos = this.getMousePos(e);
        let mouseX = pos.x;
        let mouseY = pos.y;
        // 0. inside movable rectangle
        if (this.checkInRect(mouseX, mouseY, this.rect)) {
            this.dragWholeRect = true;
            this.startX = mouseX;
            this.startY = mouseY;
        } else if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top)) this.dragTL = true;
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top)) this.dragTR = true;
        else if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.dragBL = true;
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.dragBR = true;
        this.drawRectInCanvas();
    }
    // Add the rest of the helper functions like getMousePos, checkInRect, checkCloseEnough here.
    getMousePos(evt) {
        let clx = evt.clientX;
        let cly = evt.clientY;
        let boundingRect = this.element.getBoundingClientRect();
        return {
            x: clx - boundingRect.left,
            y: cly - boundingRect.top
        };
    }
    checkInRect(x, y, r) {
        return x > r.left && x < r.width + r.left && y > r.top && y < r.top + r.height;
    }
    checkCloseEnough(p1, p2) {
        return Math.abs(p1 - p2) < this.handleRadius;
    }
    mouseMove(e) {
        let pos = this.getMousePos(e);
        let mouseX = pos.x;
        let mouseY = pos.y;
        // Update the cursor style based on mouse position
        this.updateCursorStyle(mouseX, mouseY);
        if (this.dragWholeRect) {
            e.preventDefault();
            e.stopPropagation();
            let dx = mouseX - this.startX;
            let dy = mouseY - this.startY;
            if (this.rect.left + dx > 0 && this.rect.left + dx + this.rect.width < this.overlayCanvas.width) this.rect.left += dx;
            if (this.rect.top + dy > 0 && this.rect.top + dy + this.rect.height < this.overlayCanvas.height) this.rect.top += dy;
            this.startX = mouseX;
            this.startY = mouseY;
        } else if (this.dragTL) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(this.rect.left + this.rect.width - mouseX) + Math.abs(this.rect.height + this.rect.top - mouseY)) / 2;
            if (newSide > 150) {
                this.rect.left = this.rect.left + this.rect.width - newSide;
                this.rect.top = this.rect.height + this.rect.top - newSide;
                this.rect.width = this.rect.height = newSide;
            }
        } else if (this.dragTR) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(mouseX - this.rect.left) + Math.abs(this.rect.height + this.rect.top - mouseY)) / 2;
            if (newSide > 150) {
                this.rect.top = this.rect.height + this.rect.top - newSide;
                this.rect.width = this.rect.height = newSide;
            }
        } else if (this.dragBL) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(this.rect.left + this.rect.width - mouseX) + Math.abs(this.rect.top - mouseY)) / 2;
            if (newSide > 150) {
                this.rect.left = this.rect.left + this.rect.width - newSide;
                this.rect.width = this.rect.height = newSide;
            }
        } else if (this.dragBR) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(mouseX - this.rect.left) + Math.abs(mouseY - this.rect.top)) / 2;
            if (newSide > 150) this.rect.width = this.rect.height = newSide;
        }
        this.drawRectInCanvas();
    }
    updateCursorStyle(mouseX, mouseY) {
        if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top)) this.overlayCanvas.style.cursor = "nwse-resize"; // Top left corner
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top)) this.overlayCanvas.style.cursor = "nesw-resize"; // Top right corner
        else if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.overlayCanvas.style.cursor = "nesw-resize"; // Bottom left corner
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.overlayCanvas.style.cursor = "nwse-resize"; // Bottom right corner
        else this.overlayCanvas.style.cursor = "default"; // Default cursor elsewhere
    }
    mouseUp(e) {
        this.dragTL = this.dragTR = this.dragBL = this.dragBR = false;
        this.dragWholeRect = false;
        this.storeCoordinates();
    }
    storeCoordinates() {
        // ... implementation of storeCoordinates
        let topleft = {
            x: this.rect.left,
            y: this.rect.top
        };
        let bottomright = {
            x: this.rect.left + this.rect.width,
            y: this.rect.top + this.rect.height
        };
        // console.log("Top Left:", topleft, "Bottom Right:", bottomright);
        this.callback(topleft, bottomright); // Invoke the callback with the coordinates
    }
} // Usage:
 // Assuming `callback` is a function that handles the top-left and bottom-right coordinates
 // And `element` is the canvas element to which the bounding box should be applied
 //   let element = document.getElementById('canvas');
 //   let resizableBox = new ResizableBBox(element);
 //   resizableBox.init();



class $7793c54052473bb7$export$bd64c5827f1eba0c extends (0, $5018ea9c30d774e7$export$247262aa28c26769) {
    constructor(element, callback){
        super(element);
        this.callback = callback;
        this.isDrawing = false;
        this.startX = 0;
        this.startY = 0;
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;
    }
    init() {
        super.init();
        this.overlayCanvas.style.cursor = "crosshair"; // Set the cursor to crosshair
        this.attachEventListeners();
    }
    attachEventListeners() {
        this.overlayCanvas.addEventListener("mousedown", this.mouseDown.bind(this));
        this.overlayCanvas.addEventListener("mousemove", this.mouseMove.bind(this));
        this.overlayCanvas.addEventListener("mouseup", this.mouseUp.bind(this));
        this.overlayCanvas.addEventListener("mouseout", this.mouseOut.bind(this));
    }
    mouseDown(e) {
        this.startX = e.offsetX;
        this.startY = e.offsetY;
        this.isDrawing = true;
        this.x1 = e.clientX;
        this.y1 = e.clientY;
        console.log("Mouse down at: ", this.startX, this.startY);
    }
    mouseMove(e) {
        if (!this.isDrawing) return;
        this.ctx.clearRect(0, 0, this.element.width, this.element.height); // Clear canvas
        let width = e.offsetX - this.startX;
        let height = e.offsetY - this.startY;
        this.ctx.strokeRect(this.startX, this.startY, width, height);
    }
    mouseUp(e) {
        this.isDrawing = false;
        this.x2 = e.clientX;
        this.y2 = e.clientY;
        console.log("Mouse up at: ", this.x2, this.y2);
        this.storeCoordinates();
    }
    mouseOut() {
        if (this.isDrawing) // Store coordinates also when the mouse accidentally leaves the canvas
        this.storeCoordinates();
        this.isDrawing = false;
    }
    storeCoordinates() {
        let topleft = {
            x: this.x1,
            y: this.y1
        };
        let bottomright = {
            x: this.x2,
            y: this.y2
        };
        // console.log("Top Left:", topleft, "Bottom Right:", bottomright);
        this.callback(topleft, bottomright); // Invoke the callback with the coordinates
    }
} // Usage:
 // Assuming `callback` is a function that handles the top-left and bottom-right coordinates
 // And `element` is the canvas element to which the bounding box should be applied
 // let element = document.getElementById('canvas');
 // let bbox = new BBox(element, callback);
 // bbox.init();


window.console.log("BoxCraft VERSION 0.1-alpha");
// register global namespace with a new BoxCraft instance
window.BoxCraft = new (0, $5018ea9c30d774e7$export$247262aa28c26769)();
const $4fa36e821943b400$var$canvasElement = document.getElementById("boxCanvas");
const $4fa36e821943b400$var$ctx = $4fa36e821943b400$var$canvasElement.getContext("2d");
$4fa36e821943b400$var$canvasElement.width = window.innerWidth;
$4fa36e821943b400$var$canvasElement.height = window.innerHeight;
const $4fa36e821943b400$var$image = new Image();
$4fa36e821943b400$var$image.src = "src/images/minions.jpg";
$4fa36e821943b400$var$image.onload = function() {
    $4fa36e821943b400$var$ctx.drawImage($4fa36e821943b400$var$image, 0, 0, window.innerWidth, window.innerHeight);
};
document.getElementById("createResizableBox").addEventListener("click", ()=>{
    let resizableBox = new (0, $c8d567a4be5c9a89$export$dd23631818154ff)($4fa36e821943b400$var$canvasElement, (topleft, bottomright)=>{
        console.log("Resizable Box coordinates:", topleft, bottomright);
    });
    resizableBox.init();
});
document.getElementById("createBoundingBox").addEventListener("click", ()=>{
    let bbox = new (0, $7793c54052473bb7$export$bd64c5827f1eba0c)($4fa36e821943b400$var$canvasElement, (topleft, bottomright)=>{
        console.log("Bounding Box coordinates:", topleft, bottomright);
    });
    bbox.init();
});


//# sourceMappingURL=boxCraft.min.js.map
