class $5018ea9c30d774e7$export$247262aa28c26769 {
    constructor(element){
        this.element = element;
    // Common properties for selection tools could be initialized here
    }
    init() {
        // Initialization logic common to both selectors could be here
        //   console.log("BoxCraft.init")
        this.element.width = window.innerWidth;
        this.element.height = window.innerHeight;
        this.element.style.border = "2px solid red";
        this.element.style.position = "absolute";
        // this.element.style.top = '0';
        // this.element.style.left = '0';
        this.element.style.zIndex = "1000"; // High value to ensure it's on top
    }
}



class $c8d567a4be5c9a89$export$dd23631818154ff extends (0, $5018ea9c30d774e7$export$247262aa28c26769) {
    constructor(element, callback){
        super(element);
        this.callback = callback;
        this.rect = {};
        this.handleRadius = 5;
        this.dragTL = this.dragBL = this.dragTR = this.dragBR = false;
        this.dragWholeRect = false;
    }
    init() {
        super.init();
        this.canvas = this.element;
        this.initCanvas();
        this.initRect();
        this.drawRectInCanvas();
        this.attachResizeListeners();
    }
    initCanvas() {
        // // Assuming `image` is globally available or passed to the constructor
        // this.canvas.height = image.height;
        // this.canvas.width = image.width;
        // this.canvas.style.top = image.offsetTop + "px";
        // this.canvas.style.left = image.offsetLeft + "px";
        // Assuming `element` is globally available or passed to the constructor
        this.canvas.height = this.element.height;
        this.canvas.width = this.element.width;
        this.canvas.style.top = this.element.offsetTop + "px";
        this.canvas.style.left = this.element.offsetLeft + "px";
    }
    initRect() {
        this.rect.height = 200;
        this.rect.width = 200;
        this.rect.left = (window.innerWidth - this.rect.width) / 2;
        this.rect.top = (window.innerHeight - this.rect.height) / 2;
    }
    drawRectInCanvas() {
        var ctx = this.canvas.getContext("2d");
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.beginPath();
        ctx.lineWidth = "6";
        ctx.fillStyle = "rgba(199, 87, 231, 0.2)";
        ctx.strokeStyle = "#c757e7";
        ctx.rect(this.rect.left, this.rect.top, this.rect.width, this.rect.height);
        ctx.fill();
        ctx.stroke();
        this.drawHandles();
    }
    drawHandles() {
        this.drawCircle(this.rect.left, this.rect.top, this.handleRadius);
        this.drawCircle(this.rect.left + this.rect.width, this.rect.top, this.handleRadius);
        this.drawCircle(this.rect.left + this.rect.width, this.rect.top + this.rect.height, this.handleRadius);
        this.drawCircle(this.rect.left, this.rect.top + this.rect.height, this.handleRadius);
    }
    drawCircle(x, y, radius) {
        var ctx = this.canvas.getContext("2d");
        ctx.fillStyle = "#c757e7";
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
    }
    attachResizeListeners() {
        this.canvas.addEventListener("mousedown", this.mouseDown.bind(this), false);
        this.canvas.addEventListener("mouseup", this.mouseUp.bind(this), false);
        this.canvas.addEventListener("mousemove", this.mouseMove.bind(this), false);
    }
    mouseDown(e) {
        // ... implementation of mouseDown
        let pos = this.getMousePos(e);
        let mouseX = pos.x;
        let mouseY = pos.y;
        // 0. inside movable rectangle
        if (this.checkInRect(mouseX, mouseY, this.rect)) {
            this.dragWholeRect = true;
            this.startX = mouseX;
            this.startY = mouseY;
        } else if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top)) this.dragTL = true;
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top)) this.dragTR = true;
        else if (this.checkCloseEnough(mouseX, this.rect.left) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.dragBL = true;
        else if (this.checkCloseEnough(mouseX, this.rect.left + this.rect.width) && this.checkCloseEnough(mouseY, this.rect.top + this.rect.height)) this.dragBR = true;
        this.drawRectInCanvas();
    }
    // Add the rest of the helper functions like getMousePos, checkInRect, checkCloseEnough here.
    getMousePos(evt) {
        let clx = evt.clientX;
        let cly = evt.clientY;
        let boundingRect = this.element.getBoundingClientRect();
        return {
            x: clx - boundingRect.left,
            y: cly - boundingRect.top
        };
    }
    checkInRect(x, y, r) {
        return x > r.left && x < r.width + r.left && y > r.top && y < r.top + r.height;
    }
    checkCloseEnough(p1, p2) {
        return Math.abs(p1 - p2) < this.handleRadius;
    }
    mouseMove(e) {
        let pos = this.getMousePos(e);
        let mouseX = pos.x;
        let mouseY = pos.y;
        if (this.dragWholeRect) {
            e.preventDefault();
            e.stopPropagation();
            let dx = mouseX - this.startX;
            let dy = mouseY - this.startY;
            if (this.rect.left + dx > 0 && this.rect.left + dx + this.rect.width < this.canvas.width) this.rect.left += dx;
            if (this.rect.top + dy > 0 && this.rect.top + dy + this.rect.height < this.canvas.height) this.rect.top += dy;
            this.startX = mouseX;
            this.startY = mouseY;
        } else if (this.dragTL) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(this.rect.left + this.rect.width - mouseX) + Math.abs(this.rect.height + this.rect.top - mouseY)) / 2;
            if (newSide > 150) {
                this.rect.left = this.rect.left + this.rect.width - newSide;
                this.rect.top = this.rect.height + this.rect.top - newSide;
                this.rect.width = this.rect.height = newSide;
            }
        } else if (this.dragTR) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(mouseX - this.rect.left) + Math.abs(this.rect.height + this.rect.top - mouseY)) / 2;
            if (newSide > 150) {
                this.rect.top = this.rect.height + this.rect.top - newSide;
                this.rect.width = this.rect.height = newSide;
            }
        } else if (this.dragBL) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(this.rect.left + this.rect.width - mouseX) + Math.abs(this.rect.top - mouseY)) / 2;
            if (newSide > 150) {
                this.rect.left = this.rect.left + this.rect.width - newSide;
                this.rect.width = this.rect.height = newSide;
            }
        } else if (this.dragBR) {
            e.preventDefault();
            e.stopPropagation();
            let newSide = (Math.abs(mouseX - this.rect.left) + Math.abs(mouseY - this.rect.top)) / 2;
            if (newSide > 150) this.rect.width = this.rect.height = newSide;
        }
        this.drawRectInCanvas();
    }
    mouseUp(e) {
        this.dragTL = this.dragTR = this.dragBL = this.dragBR = false;
        this.dragWholeRect = false;
        this.storeCoordinates();
    }
    storeCoordinates() {
        // ... implementation of storeCoordinates
        let topleft = {
            x: this.rect.left,
            y: this.rect.top
        };
        let bottomright = {
            x: this.rect.left + this.rect.width,
            y: this.rect.top + this.rect.height
        };
        // console.log("Top Left:", topleft, "Bottom Right:", bottomright);
        this.callback(topleft, bottomright); // Invoke the callback with the coordinates
    }
} // Usage:
 // Assuming `callback` is a function that handles the top-left and bottom-right coordinates
 // And `element` is the canvas element to which the bounding box should be applied
 //   let element = document.getElementById('canvas');
 //   let resizableBox = new ResizableBBox(element);
 //   resizableBox.init();



class $7793c54052473bb7$export$bd64c5827f1eba0c extends (0, $5018ea9c30d774e7$export$247262aa28c26769) {
    constructor(element, callback){
        super(element);
        this.callback = callback;
        this.ctx = this.element.getContext("2d");
        this.isDrawing = false;
        this.startX = 0;
        this.startY = 0;
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;
    }
    init() {
        super.init();
        this.attachEventListeners();
    }
    attachEventListeners() {
        this.element.addEventListener("mousedown", this.mouseDown.bind(this));
        this.element.addEventListener("mousemove", this.mouseMove.bind(this));
        this.element.addEventListener("mouseup", this.mouseUp.bind(this));
        this.element.addEventListener("mouseout", this.mouseOut.bind(this));
    }
    mouseDown(e) {
        this.startX = e.offsetX;
        this.startY = e.offsetY;
        this.isDrawing = true;
        this.x1 = e.clientX;
        this.y1 = e.clientY;
        console.log("Mouse down at: ", this.startX, this.startY);
    }
    mouseMove(e) {
        if (!this.isDrawing) return;
        this.ctx.clearRect(0, 0, this.element.width, this.element.height); // Clear canvas
        let width = e.offsetX - this.startX;
        let height = e.offsetY - this.startY;
        this.ctx.strokeRect(this.startX, this.startY, width, height);
    }
    mouseUp(e) {
        this.isDrawing = false;
        this.x2 = e.clientX;
        this.y2 = e.clientY;
        console.log("Mouse up at: ", this.x2, this.y2);
        this.storeCoordinates();
    }
    mouseOut() {
        if (this.isDrawing) // Store coordinates also when the mouse accidentally leaves the canvas
        this.storeCoordinates();
        this.isDrawing = false;
    }
    storeCoordinates() {
        let topleft = {
            x: this.x1,
            y: this.y1
        };
        let bottomright = {
            x: this.x2,
            y: this.y2
        };
        // console.log("Top Left:", topleft, "Bottom Right:", bottomright);
        this.callback(topleft, bottomright); // Invoke the callback with the coordinates
    }
} // Usage:
 // Assuming `callback` is a function that handles the top-left and bottom-right coordinates
 // And `element` is the canvas element to which the bounding box should be applied
 // let element = document.getElementById('canvas');
 // let bbox = new BBox(element, callback);
 // bbox.init();


window.console.log("BoxCraft VERSION 0.1-alpha");
// register global namespace with a new BoxCraft instance
window.BoxCraft = new (0, $5018ea9c30d774e7$export$247262aa28c26769)();
const $4fa36e821943b400$var$canvasElement = document.getElementById("boxCanvas");
document.getElementById("createResizableBox").addEventListener("click", ()=>{
    let resizableBox = new (0, $c8d567a4be5c9a89$export$dd23631818154ff)($4fa36e821943b400$var$canvasElement, (topleft, bottomright)=>{
        console.log("Resizable Box coordinates:", topleft, bottomright);
    });
    resizableBox.init();
});
document.getElementById("createBoundingBox").addEventListener("click", ()=>{
    let bbox = new (0, $7793c54052473bb7$export$bd64c5827f1eba0c)($4fa36e821943b400$var$canvasElement, (topleft, bottomright)=>{
        console.log("Bounding Box coordinates:", topleft, bottomright);
    });
    bbox.init();
});


//# sourceMappingURL=boxCraft.min.js.map
